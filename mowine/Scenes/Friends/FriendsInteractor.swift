//
//  FriendsInteractor.swift
//  mowine
//
//  Created by Josh Freed on 3/6/18.
//  Copyright (c) 2018 Josh Freed. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit
import SwiftyBeaver

protocol FriendsBusinessLogic {
    func fetchFriends(request: Friends.FetchFriends.Request)
    func searchUsers(request: Friends.SearchUsers.Request)
    func cancelSearch()
    func addFriend(request: Friends.AddFriend.Request)
    func selectUser(request: Friends.SelectUser.Request)
    func getProfilePicture(url: URL?, completion: @escaping (UIImage) -> ())
}

protocol FriendsDataStore {
    var selectedUserId: UserId? { get }
}

class FriendsInteractor: FriendsBusinessLogic, FriendsDataStore {
    var presenter: FriendsPresentationLogic?
    var worker: FriendsWorker?
    var profilePictureWorker: ProfilePictureWorkerProtocol!
    var selectedUserId: UserId?

    enum DisplayMode {
        case friends
        case search
    }

    var displayMode: DisplayMode = .friends
    var friends: [User] = []
    var lastSearchResults: [User] = []
    var searchTimer: Timer?
    var debounceTime = 0.25
    var searches: [UUID] = []

    init(worker: FriendsWorker, profilePictureWorker: ProfilePictureWorkerProtocol) {
        self.worker = worker
        self.profilePictureWorker = profilePictureWorker
        NotificationCenter.default.addObserver(self, selector: #selector(friendWasAdded), name: .friendAdded, object: nil)
        NotificationCenter.default.addObserver(self, selector: #selector(friendWasRemoved), name: .friendRemoved, object: nil)
    }
    
    @objc func friendWasAdded(notification: Notification) {
        guard let friend = notification.userInfo?["friend"] as? User else {
            return
        }

        friends.append(friend)

        switch displayMode {
        case .friends: presentFriends()
        case .search: self.presentSearchResults(users: self.lastSearchResults)
        }
    }
    
    @objc func friendWasRemoved(notification: Notification) {
        guard let friendId = notification.userInfo?["friendId"] as? UserId else {
            return
        }

        if let index = friends.firstIndex(where: { $0.id == friendId }) {
            friends.remove(at: index)
        }

        switch displayMode {
        case .friends: presentFriends()
        case .search: self.presentSearchResults(users: self.lastSearchResults)
        }
    }

    // MARK: Fetch Friends

    func fetchFriends(request: Friends.FetchFriends.Request) {
        displayMode = .friends

        worker?.fetchMyFriends() { result in
            switch result {
            case .success(let friends):
                self.friends = friends
                self.presentFriends()
            case .failure(let error):
                // TODO print an error on screen
                SwiftyBeaver.error("\(error)")
                break
            }
        }
    }
    
    private func presentFriends() {
        let response = Friends.FetchFriends.Response(friends: friends)
        presenter?.presentFriends(response: response)
    }
    
    // MARK: Search Users

    func searchUsers(request: Friends.SearchUsers.Request) {
        displayMode = .search

        SwiftyBeaver.debug("Searching for: \(request.searchString)")

        cancelSearchTimer()
        
        guard !request.searchString.isEmpty else {
            presenter?.presentEmptySearch()
            return
        }

        SwiftyBeaver.debug("Scheduling a search after \(debounceTime) seconds")
        
        searchTimer = Timer.scheduledTimer(withTimeInterval: debounceTime, repeats: false, block: { _ in
            self.doSearch(request: request)
        })
    }
    
    private func doSearch(request: Friends.SearchUsers.Request) {
        let searchJobId = UUID()
        
        SwiftyBeaver.debug("doSearch \(searchJobId) \(request.searchString)")
        
        searches.append(searchJobId)
        
        worker?.searchUsers(searchString: request.searchString) { result in
            SwiftyBeaver.debug("Work complete for \(request.searchString)")
            
            switch result {
            case .success(let users):
                guard self.searches.contains(searchJobId) else {
                    SwiftyBeaver.debug("Not displaying search results because the search job was (probably) cancelled. \(searchJobId)")
                    return
                }
                SwiftyBeaver.debug("Presenting search results for \(searchJobId), \(request.searchString)")
                self.lastSearchResults = users
                self.presentSearchResults(users: users)
            case .failure(let error): print("\(error)")
            }
        }
    }
    
    private func presentSearchResults(users: [User]) {
        let response = Friends.SearchUsers.Response(matches: users, myFriends: friends)
        presenter?.presentSearchResults(response: response)
    }
    
    private func cancelSearchTimer() {
        searchTimer?.invalidate()
        searchTimer = nil
        searches = []
    }
    
    // MARK: Cancel search
    
    func cancelSearch() {
        displayMode = .friends
        cancelSearchTimer()
        presentFriends()
    }
    
    // MARK: Add friend
    
    func addFriend(request: Friends.AddFriend.Request) {
        let userId = UserId(string: request.userId)
        
        worker?.addFriend(userId: userId) { result in
            switch result {
            case .success(let newFriend):
                self.friends.append(newFriend)
                let response = Friends.AddFriend.Response(userId: request.userId)
                self.presenter?.presentAddFriend(response: response)
            case .failure(let error):
                print("\(error)")
                let response = Friends.AddFriend.Response(userId: request.userId)
                self.presenter?.presentAddFriendError(response: response)
            }
        }
    }
    
    // MARK: Select user
    
    func selectUser(request: Friends.SelectUser.Request) {
        let userId = UserId(string: request.userId)
        
        selectedUserId = userId
        
        let response = Friends.SelectUser.Response()
        presenter?.presentSelectedUser(response: response)
    }
    
    // MARK: Get profile picture
    
    func getProfilePicture(url: URL?, completion: @escaping (UIImage) -> ()) {
        guard let url = url else { return }
        profilePictureWorker.getProfilePicture(url: url) { result in
            if case let .success(d) = result, let data = d, let image = UIImage(data: data) {
                DispatchQueue.main.async {
                    completion(image)
                }
            }
        }
    }
}
