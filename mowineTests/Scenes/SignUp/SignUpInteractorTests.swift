//
//  SignUpInteractorTests.swift
//  mowine
//
//  Created by Josh Freed on 3/28/18.
//  Copyright (c) 2018 Josh Freed. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

@testable import mowine
import XCTest
import JFLib
import Nimble

class SignUpInteractorTests: XCTestCase {
    // MARK: Subject under test

    var sut: SignUpInteractor!
    let presenter = SignUpPresentationLogicSpy()
    let emailAuthService = TestEmailAuthService()
    let userRepository = TestUserRepository()

    // MARK: Test lifecycle

    override func setUp() {
        super.setUp()
        continueAfterFailure = false
        setupSignUpInteractor()
    }

    override func tearDown() {
        super.tearDown()
    }

    // MARK: Test setup

    func setupSignUpInteractor() {
        sut = SignUpInteractor()
        sut.presenter = presenter
        sut.worker = SignUpWorker(emailAuthService: emailAuthService, userRepository: userRepository)
    }

    // MARK: Test doubles

    class SignUpPresentationLogicSpy: SignUpPresentationLogic {
        var presentSignUpCalled = false
        var presentSignUpResponse: SignUp.SignUp.Response?
        func presentSignUp(response: SignUp.SignUp.Response) {
            presentSignUpCalled = true
            presentSignUpResponse = response
        }
        func verifyPresentedSignUpSuccess(emailAddress: String) {
            expect(self.presentSignUpCalled).to(beTrue())
            expect(self.presentSignUpResponse).toNot(beNil())
            expect(self.presentSignUpResponse?.user).toNot(beNil())
            expect(self.presentSignUpResponse?.user?.emailAddress).to(equal(emailAddress))
            expect(self.presentSignUpResponse?.error).to(beNil())
            expect(self.presentSignUpResponse?.message).to(beNil())
        }
        func verifyPresentedSignUpFailure(error: Error) {
            expect(self.presentSignUpCalled).to(beTrue())
            expect(self.presentSignUpResponse).toNot(beNil())
            expect(self.presentSignUpResponse?.user).to(beNil())
            expect(self.presentSignUpResponse?.error).toNot(beNil())
            expect(self.presentSignUpResponse?.message).to(beNil())

            var expectedError: String?
            if let err = presentSignUpResponse?.error {
                expectedError = "\(err)"
            }
            expect(expectedError).to(equal("\(error)"))
        }
        func verifyPresentedSignUpFailure(error: Error, message: String) {
            expect(self.presentSignUpCalled).to(beTrue())
            expect(self.presentSignUpResponse).toNot(beNil())
            expect(self.presentSignUpResponse?.user).to(beNil())
            expect(self.presentSignUpResponse?.error).toNot(beNil())
            expect(self.presentSignUpResponse?.message).toNot(beNil())
            expect(self.presentSignUpResponse?.message).to(equal(message))
            
            var expectedError: String?
            if let err = presentSignUpResponse?.error {
                expectedError = "\(err)"
            }
            expect(expectedError).to(equal("\(error)"))
        }
    }
    
    class TestEmailAuthService: EmailAuthenticationService {
        var identities: [String: String] = [:]
        
        func identityDoesNotExist(for emailAddress: String) {
            identities.removeValue(forKey: emailAddress)
        }
        
        func identity(for emailAddress: String, password: String) {
            identities[emailAddress] = password
        }
        
        var signInResult: EmptyResult?
        func signIn(emailAddress: String, password: String, completion: @escaping (EmptyResult) -> ()) {
            if let result = signInResult {
                completion(result)
                return
            }
            
            guard let identity = identities[emailAddress] else {
                completion(.failure(EmailAuthenticationErrors.userNotFound))
                return
            }
            
            guard identity == password else {
                completion(.failure(EmailAuthenticationErrors.notAuthorized))
                return
            }
            
            completion(.success)
        }
        func signInWillFail(error: Error) {
            signInResult = .failure(error)
        }
        
        var signUpResult: EmptyResult?
        var signedUp: String?
        func signUp(emailAddress: String, password: String, completion: @escaping (EmptyResult) -> ()) {
            signedUp = emailAddress
            identities[emailAddress] = password
            if let result = signUpResult {
                completion(result)
            }
        }
        
        func signUpWillSucceed() {
            signUpResult = .success
        }
        func signUpWillFail(error: Error) {
            signUpResult = .failure(error)
        }
        
        func verifyIdentityCreated(emailAddress: String, password: String) {
            if let pw = identities[emailAddress], pw == password {
                
            } else {
                fail("User was not signed up")
            }
        }
        
        func verifyIdentityWasNotCreated() {
            expect(self.signedUp).to(beNil())
        }
    }
    
    enum TestError: Error {
        case unknownError
    }
    
    class TestUserRepository: UserRepository {
        func doesNotContainUser(emailAddress: String) {
            
        }
        var _user: User?
        func containsUser(emailAddress: String) {
            _user = UserBuilder.aUser().withEmail(emailAddress).build()
        }
        
        var saveUserCalled = false
        var savedUser: User?
        var saveUserResult: Result<User>?
        func saveUser(user: User, completion: @escaping (Result<User>) -> ()) {
            saveUserCalled = true
            savedUser = user
            if let result = saveUserResult {
                completion(result)
            }
        }
        func saveUserWillSucceed() {
            let userToReturn = User(id: UserId(), emailAddress: "smelly@mybutt.com")
            saveUserResult = .success(userToReturn)
        }
        func saveUserWillFail(error: Error) {
            saveUserResult = .failure(error)
        }
        func verifyUserAddedToRepository(emailAddress: String, firstName: String, lastName: String) {
            expect(self.saveUserCalled).to(beTrue())
            expect(self.savedUser).toNot(beNil())
            expect(self.savedUser?.emailAddress).to(equal(emailAddress))
            expect(self.savedUser?.firstName).to(equal(firstName))
            expect(self.savedUser?.lastName).to(equal(lastName))
        }
        func verifyUserNotAddedToRepository() {
            expect(self.saveUserCalled).to(beFalse())
            expect(self.savedUser).to(beNil())
        }
        
        func getFriendsOf(userId: UserId, completion: @escaping (Result<[User]>) -> ()) {
            
        }
        
        func searchUsers(searchString: String, completion: @escaping (Result<[User]>) -> ()) {
            
        }
        
        func addFriend(owningUserId: UserId, friendId: UserId, completion: @escaping (Result<User>) -> ()) {
            
        }
        
        func removeFriend(owningUserId: UserId, friendId: UserId, completion: @escaping (EmptyResult) -> ()) {
            
        }
        
        func getUserById(_ id: UserId, completion: @escaping (Result<User?>) -> ()) {
            
        }
        
        func getUserByEmail(_ emailAddress: String, completion: @escaping (Result<User?>) -> ()) {
            completion(.success(_user))
        }
    }

    // MARK: Tests
    
    // Happy path. The user's identity is created and a user object is added to the repository
    func test_signUp() {
        // Given
        emailAuthService.identityDoesNotExist(for: "jbone@test.com")
        emailAuthService.signUpWillSucceed()
        userRepository.saveUserWillSucceed()
        let request = SignUp.SignUp.Request(firstName: "Jeff", lastName: "Beans", emailAddress: "jbone@test.com", password: "password123")

        // When
        sut.signUp(request: request)

        // Then
        emailAuthService.verifyIdentityCreated(emailAddress: "jbone@test.com", password: "password123")
        userRepository.verifyUserAddedToRepository(emailAddress: "jbone@test.com", firstName: "Jeff", lastName: "Beans")
        presenter.verifyPresentedSignUpSuccess(emailAddress: "jbone@test.com")
    }
    
    func test_signUp_emailAddressAlreadyExists() {
        // Given
        emailAuthService.identity(for: "jbone@test.com", password: "whatever")
        let request = SignUp.SignUp.Request(firstName: "Jeff", lastName: "Beans", emailAddress: "jbone@test.com", password: "password123")
        
        // When
        sut.signUp(request: request)
        
        // Then
        
        emailAuthService.verifyIdentityWasNotCreated()
        userRepository.verifyUserNotAddedToRepository()
        presenter.verifyPresentedSignUpFailure(
            error: EmailAuthenticationErrors.emailAddressAlreadyInUse,
            message: "That email address is already associated with an account. Try signing in or resetting your password."
        )
    }
    
    // This scenario can happen if the user completes the sign up part of the flow, but there's an error adding the user to repository
    // Without this case, the emailAuth service would try to sign up the user again, and likely be told "there's already a user with this email address"
    func test_signUp_userIdentityExistsButUserIsNotInRepository() {
        // Given
        emailAuthService.identity(for: "jbone@test.com", password: "password123")
        userRepository.doesNotContainUser(emailAddress: "jbone@test.com")
        userRepository.saveUserWillSucceed()
        let request = SignUp.SignUp.Request(firstName: "Jeff", lastName: "Beans", emailAddress: "jbone@test.com", password: "password123")
        
        // When
        sut.signUp(request: request)
        
        // Then
        emailAuthService.verifyIdentityWasNotCreated()
        userRepository.verifyUserAddedToRepository(emailAddress: "jbone@test.com", firstName: "Jeff", lastName: "Beans")
        presenter.verifyPresentedSignUpSuccess(emailAddress: "jbone@test.com")
    }

    func test_signUp_anErrorOccursWhileCreatingTheIdentity() {
        // Given
        emailAuthService.identityDoesNotExist(for: "jbone@test.com")
        emailAuthService.signUpWillFail(error: TestError.unknownError)
        let request = SignUp.SignUp.Request(firstName: "Jeff", lastName: "Beans", emailAddress: "jbone@test.com", password: "password123")
        
        // When
        sut.signUp(request: request)
        
        // Then
        userRepository.verifyUserNotAddedToRepository()
        presenter.verifyPresentedSignUpFailure(error: TestError.unknownError)
    }
    
    func test_signUp_anErrorOccursWhileAddingTheUserToTheRepository() {
        // Given
        emailAuthService.identityDoesNotExist(for: "jbone@test.com")
        emailAuthService.signUpWillSucceed()
        userRepository.saveUserWillFail(error: TestError.unknownError)
        let request = SignUp.SignUp.Request(firstName: "Jeff", lastName: "Beans", emailAddress: "jbone@test.com", password: "password123")
        
        // When
        sut.signUp(request: request)
        
        // Then
        emailAuthService.verifyIdentityCreated(emailAddress: "jbone@test.com", password: "password123")
        presenter.verifyPresentedSignUpFailure(error: TestError.unknownError)
    }
    
    func test_signUp_theEmailAuthServiceRejectsThePassword() {
        // Given
        let error = EmailAuthenticationErrors.invalidPassword(message: "Your password is invalid")
        emailAuthService.identityDoesNotExist(for: "jbone@test.com")
        emailAuthService.signUpWillFail(error: error)
        let request = SignUp.SignUp.Request(firstName: "Jeff", lastName: "Beans", emailAddress: "jbone@test.com", password: "password123")
        
        // When
        sut.signUp(request: request)
        
        // Then
        userRepository.verifyUserNotAddedToRepository()
        presenter.verifyPresentedSignUpFailure(error: error, message: "Your password is invalid")
    }
    
    func test_signUp_theSignInActionHasAnError() {
        // Given
        emailAuthService.signInWillFail(error: TestError.unknownError)
        let request = SignUp.SignUp.Request(firstName: "Jeff", lastName: "Beans", emailAddress: "jbone@test.com", password: "password123")
        
        // When
        sut.signUp(request: request)        
        
        // Then
        emailAuthService.verifyIdentityWasNotCreated()
        userRepository.verifyUserNotAddedToRepository()
        presenter.verifyPresentedSignUpFailure(error: TestError.unknownError)
    }
    
    // The user signs up w/ an exist identity and the correct password.
    // The user object exists in the repository.
    // Don't create a new identity; Don't insert a new user object. Just do nothing, and sign in.
    // I really don't know how this scenario could happen...
    func test_signUp_userIdentityExists_and_userIsInRepository() {
        // Given
        emailAuthService.identity(for: "jbone@test.com", password: "password123")
        userRepository.containsUser(emailAddress: "jbone@test.com")
        let request = SignUp.SignUp.Request(firstName: "Jeff", lastName: "Beans", emailAddress: "jbone@test.com", password: "password123")
        
        // When
        sut.signUp(request: request)
        
        // Then
        emailAuthService.verifyIdentityWasNotCreated()
        userRepository.verifyUserNotAddedToRepository()
        presenter.verifyPresentedSignUpSuccess(emailAddress: "jbone@test.com")
    }
}
