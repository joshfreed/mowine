//
//  EditWineWorkerTests.swift
//  mowine
//
//  Created by Josh Freed on 6/4/17.
//  Copyright (c) 2017 BleepSmazz. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so you can apply
//  clean architecture to your iOS and Mac projects, see http://clean-swift.com
//

@testable import mowine
import XCTest
import JFLib
import Nimble

class EditWineWorkerTests: XCTestCase {
    // MARK: - Subject under test

    var sut: EditWineWorker!
    var imageWorker = MockWineImageWorker()
    var wine: Wine!
    let wineRepo = MockWineRepository()
    let typeRepo = MockWineTypeRepository()
    let varietyRepo = MockWineVarietyRepository()

    // MARK: - Test lifecycle

    override func setUp() {
        super.setUp()
        setupEditWineWorker()
        wine = Wine(
            type: WineType(name: "Red", varieties: []),
            variety: WineVariety(name: "Merlot"),
            name: "Test Wine",
            rating: 5
        )
    }

    override func tearDown() {
        super.tearDown()
    }

    // MARK: - Test setup

    func setupEditWineWorker() {
        sut = EditWineWorker(
            wineRepository: wineRepo,
            wineTypeRepository: typeRepo,
            wineVarietyRepository: varietyRepo,
            imageWorker: imageWorker
        )
    }

    // MARK: - Test doubles

    // MARK: - Tests

    func testUpdateWine() {
        // Given
        var request = EditWine.SaveWine.Request(
            name: "New Name",
            rating: 4,
            type: WineTypeViewModel(name: "Thing", varieties: []),
            variety: "Merlot"
        )
        request.location = "Wegmans"
        request.notes = "Wine tasted good"
        request.price = 400
        request.pairings = ["Tacos", "Sushi"]
        var updatedWine: Wine?
        varietyRepo.varieties = [WineVariety(name: "Merlot")]

        // When
        sut.updateWine(wine: wine, from: request) { result in            
            if case let .success(w) = result {
                updatedWine = w
            }
        }

        // Then
        expect(updatedWine).toNot(beNil())
        expect(updatedWine?.name).to(equal(request.name))
        expect(updatedWine?.rating).to(equal(request.rating))
        expect(updatedWine?.location).to(equal(request.location))
        expect(updatedWine?.notes).to(equal(request.notes))
        expect(updatedWine?.price).to(equal(400))
        expect(updatedWine?.pairings).to(haveCount(2))
        expect(updatedWine?.pairings).to(contain(["Tacos", "Sushi"]))
        XCTAssertNil(updatedWine?.photo)
        XCTAssertNil(updatedWine?.thumbnail)
    }
    
    /*
    func testMergePairingsAddsNewPairings() {
        sut.mergePairings(wine: wine, pairings: ["Sushi", "Cheese"])

        let pairings = getPairings()
        XCTAssertEqual(2, pairings.count)
        XCTAssertTrue(pairings.contains(where: { $0.name == "Sushi" }))
        XCTAssertTrue(pairings.contains(where: { $0.name == "Cheese" }))
    }

    func testMergePairingsDoesNotAddTheSamePairingTwice() {
        addPairing("Sushi")
        
        sut.mergePairings(wine: wine, pairings: ["Sushi"])
        
        let pairings = getPairings()
        XCTAssertEqual(1, pairings.count)
        XCTAssertTrue(pairings.contains(where: { $0.name == "Sushi" }))
    }
    
    func testMergePairingsRemovesMissingPairing() {
        addPairing("Sushi")
        addPairing("Cheese")
        
        sut.mergePairings(wine: wine, pairings: ["Cheese"])
        
        let pairings = getPairings()
        XCTAssertEqual(1, pairings.count)
        XCTAssertTrue(pairings.contains(where: { $0.name == "Cheese" }))
    }

    func testMergePairingsIsNotCaseSensative() {
        addPairing("Sushi")
        
        sut.mergePairings(wine: wine, pairings: ["sUSHi"])
        
        let pairings = getPairings()
        XCTAssertEqual(1, pairings.count)
        XCTAssertTrue(pairings.contains(where: { $0.name == "Sushi" }))
    }
    
    private func getPairings() -> [Food] {
        if let pairings = Array(wine.pairings ?? []) as? [Food] {
            XCTAssertNotNil(pairings)
            return pairings
        } else {
            XCTFail("Could not unwrap pairings nset")
            return []
        }
    }
    
    private func addPairing(_ foodName: String) {
        let food = NSEntityDescription.insertNewObject(forEntityName: "Food", into: context) as! Food
        food.name = foodName
        wine.addToPairings(food)
    }
     */
}
